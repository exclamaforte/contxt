#!/usr/bin/env python3
"""
contxt - Git worktree manager for AI agent workflows
"""


import os
import sys
import json
import argparse
import subprocess
import shutil
import datetime
from pathlib import Path
from typing import Dict, Optional, List, Tuple


class ContxtManager:
    """Manages git worktrees with metadata tracking"""

    def __init__(self):
        self.worktrees_base = Path.home() / "worktrees"
        self.venvs_base = Path.home() / "venvs"
        self.metadata_file = self.worktrees_base / ".contxt_metadata.json"
        self.worktrees_base.mkdir(parents=True, exist_ok=True)
        self.venvs_base.mkdir(parents=True, exist_ok=True)
        self.metadata = self._load_metadata()

    def _load_metadata(self) -> Dict:
        """Load metadata from JSON file"""
        if self.metadata_file.exists():
            try:
                with open(self.metadata_file, "r") as f:
                    return json.load(f)
            except json.JSONDecodeError:
                return {}
        return {}

    def _save_metadata(self):
        """Save metadata to JSON file"""
        with open(self.metadata_file, "w") as f:
            json.dump(self.metadata, f, indent=2)

    def _get_git_root(self) -> Path:
        """Get the root directory of the current git repository"""
        try:
            result = subprocess.run(
                ["git", "rev-parse", "--show-toplevel"],
                capture_output=True,
                text=True,
                check=True,
            )
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            print("Error: Not in a git repository", file=sys.stderr)
            sys.exit(1)

    def _get_git_name(self, git_root: Optional[Path] = None) -> str:
        """Get the name of the git repository"""
        if git_root is None:
            git_root = self._get_git_root()
        return git_root.name

    def _find_worktree_info(self, cwd: Path) -> Optional[Tuple[str, str]]:
        """
        Check if current directory is inside a worktree and return (git_name, worktree_name).
        Returns None if not in a tracked worktree.
        """
        cwd_str = str(cwd)
        for git_name, worktrees in self.metadata.items():
            for wt_name, wt_info in worktrees.items():
                wt_path = wt_info["worktree_path"]
                if cwd_str.startswith(wt_path):
                    return (git_name, wt_name)
        return None

    def _get_current_branch(self, git_root: Path) -> str:
        """Get the current branch name"""
        try:
            result = subprocess.run(
                ["git", "-C", str(git_root), "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                check=True,
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return "main"

    def _create_worktree_common(
        self, name: str, project: Optional[str] = None
    ) -> Tuple[str, Path, Path, str]:
        """
        Common logic for creating a worktree with venv.
        Returns (git_name, worktree_path, venv_path, branch_name)
        """
        # Check if we're in a worktree and resolve to original repo
        cwd = Path.cwd()
        worktree_info_tuple = self._find_worktree_info(cwd)

        if worktree_info_tuple and not project:
            # We're in a worktree, resolve to original repo root
            git_name_from_worktree, current_worktree_name = worktree_info_tuple
            git_root = Path(
                self.metadata[git_name_from_worktree][current_worktree_name][
                    "original_repo"
                ]
            )
            git_name = git_name_from_worktree
        else:
            # Not in a worktree or project explicitly specified
            git_root = self._get_git_root()
            git_name = project if project else self._get_git_name(git_root)

        # Create worktree directory structure
        worktree_parent = self.worktrees_base / git_name
        worktree_path = worktree_parent / name

        if worktree_path.exists():
            print(
                f"Error: Worktree '{name}' already exists for project '{git_name}'",
                file=sys.stderr,
            )
            sys.exit(1)

        worktree_parent.mkdir(parents=True, exist_ok=True)

        # Create git worktree with new branch
        branch_name = f"worktree/{name}"
        try:
            subprocess.run(
                [
                    "git",
                    "-C",
                    str(git_root),
                    "worktree",
                    "add",
                    "-b",
                    branch_name,
                    str(worktree_path),
                ],
                check=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error creating worktree: {e}", file=sys.stderr)
            sys.exit(1)

        # Create Python venv in separate directory
        venv_parent = self.venvs_base / git_name
        venv_parent.mkdir(parents=True, exist_ok=True)
        venv_path = venv_parent / name
        try:
            subprocess.run(["python3", "-m", "venv", str(venv_path)], check=True)
        except subprocess.CalledProcessError as e:
            print(f"Warning: Failed to create venv: {e}", file=sys.stderr)

        # Store metadata
        if git_name not in self.metadata:
            self.metadata[git_name] = {}

        self.metadata[git_name][name] = {
            "worktree_path": str(worktree_path),
            "original_repo": str(git_root),
            "branch": branch_name,
            "venv_path": str(venv_path),
        }
        self._save_metadata()

        print(f"Created worktree '{name}' for project '{git_name}'")
        print(f"  Path: {worktree_path}")
        print(f"  Branch: {branch_name}")
        print(f"  Venv: {venv_path}")
        print(f"\nTo activate venv:")
        print(f"  source {venv_path}/bin/activate")

        return (git_name, worktree_path, venv_path, branch_name)

    def create(self, name: str, project: Optional[str] = None):
        """Create a new worktree with venv"""
        # Use common worktree creation logic
        git_name, worktree_path, venv_path, branch_name = self._create_worktree_common(
            name, project
        )

        # Open in VS Code
        try:
            subprocess.run(["code", str(worktree_path)], check=True)
            print(f"\nOpened '{name}' in VS Code")
        except subprocess.CalledProcessError as e:
            print(f"\nWarning: Failed to open VS Code: {e}", file=sys.stderr)
        except FileNotFoundError:
            print(
                "\nWarning: 'code' command not found. Install VS Code CLI to auto-open.",
                file=sys.stderr,
            )

    def edit(self, name: str, project: Optional[str] = None):
        """Open worktree in VS Code"""
        # Check if we're in a worktree and use its git_name
        cwd = Path.cwd()
        worktree_info_tuple = self._find_worktree_info(cwd)

        if project:
            git_name = project
        elif worktree_info_tuple:
            git_name, _ = worktree_info_tuple
        else:
            try:
                git_name = self._get_git_name()
            except SystemExit:
                print(
                    "Error: Not in a git repository. Use -p to specify project.",
                    file=sys.stderr,
                )
                sys.exit(1)

        if git_name not in self.metadata or name not in self.metadata[git_name]:
            print(
                f"Error: Worktree '{name}' not found for project '{git_name}'",
                file=sys.stderr,
            )
            sys.exit(1)

        worktree_path = self.metadata[git_name][name]["worktree_path"]

        if not Path(worktree_path).exists():
            print(
                f"Error: Worktree path does not exist: {worktree_path}", file=sys.stderr
            )
            sys.exit(1)

        try:
            subprocess.run(["code", worktree_path], check=True)
            print(f"Opened '{name}' in VS Code")
        except subprocess.CalledProcessError as e:
            print(f"Error opening VS Code: {e}", file=sys.stderr)
            sys.exit(1)
        except FileNotFoundError:
            print(
                "Error: 'code' command not found. Make sure VS Code CLI is installed.",
                file=sys.stderr,
            )
            sys.exit(1)

    def delete(self, name: str, project: Optional[str] = None):
        """Delete a worktree by moving it to /tmp"""
        # Check if we're in a worktree and use its git_name
        cwd = Path.cwd()
        worktree_info_tuple = self._find_worktree_info(cwd)

        if project:
            git_name = project
        elif worktree_info_tuple:
            git_name, _ = worktree_info_tuple
        else:
            try:
                git_name = self._get_git_name()
            except SystemExit:
                print(
                    "Error: Not in a git repository. Use -p to specify project.",
                    file=sys.stderr,
                )
                sys.exit(1)

        if git_name not in self.metadata or name not in self.metadata[git_name]:
            print(
                f"Error: Worktree '{name}' not found for project '{git_name}'",
                file=sys.stderr,
            )
            sys.exit(1)

        worktree_info = self.metadata[git_name][name]
        worktree_path = Path(worktree_info["worktree_path"])
        original_repo = worktree_info["original_repo"]
        branch_name = worktree_info["branch"]

        # Create timestamped backup location in /tmp
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        tmp_base = Path("/tmp") / "contxt_deleted"
        tmp_base.mkdir(parents=True, exist_ok=True)
        backup_path = tmp_base / f"{git_name}_{name}_{timestamp}"

        # Remove from git worktree tracking first
        try:
            subprocess.run(
                [
                    "git",
                    "-C",
                    original_repo,
                    "worktree",
                    "remove",
                    "--force",
                    str(worktree_path),
                ],
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"Warning: Failed to remove worktree via git: {e}", file=sys.stderr)

        # Move directory to /tmp instead of deleting
        if worktree_path.exists():
            try:
                shutil.move(str(worktree_path), str(backup_path))
                print(f"Moved worktree to: {backup_path}")
                print(f"(Will be cleaned up on next reboot)")
            except Exception as e:
                print(f"Warning: Failed to move worktree to /tmp: {e}", file=sys.stderr)

        # Delete branch
        try:
            subprocess.run(
                ["git", "-C", original_repo, "branch", "-D", branch_name],
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError:
            pass  # Branch might already be deleted

        # Update metadata
        del self.metadata[git_name][name]
        if not self.metadata[git_name]:
            del self.metadata[git_name]
        self._save_metadata()

        print(f"Deleted worktree '{name}' from project '{git_name}'")

    def list(self, project: Optional[str] = None):
        """List all worktrees"""
        if not self.metadata:
            print("No worktrees found")
            return

        if project:
            if project not in self.metadata:
                print(f"No worktrees found for project '{project}'")
                return
            projects_to_list = {project: self.metadata[project]}
        else:
            projects_to_list = self.metadata

        for git_name, worktrees in sorted(projects_to_list.items()):
            print(git_name)
            for wt_name in sorted(worktrees.keys()):
                print(f"  {wt_name}")

    def merge(self, name: str, project: Optional[str] = None):
        """Merge worktree branch into main branch of original repo"""
        # Check if we're currently in a worktree
        cwd = Path.cwd()
        worktree_info_tuple = self._find_worktree_info(cwd)

        # Determine git_name and name
        if project:
            # Explicit project specified
            git_name = project
        elif worktree_info_tuple:
            # We're in a tracked worktree - use the metadata's git_name
            git_name, detected_name = worktree_info_tuple
            # If name matches what we detected, we're trying to merge current worktree
            if name == detected_name:
                print(f"Detected current worktree: {git_name}/{name}")
        else:
            # Not in a worktree, try to get from current git repo
            try:
                git_name = self._get_git_name()
            except SystemExit:
                # Not in a git repo at all, must specify project
                print(
                    "Error: Not in a git repository. Use -p to specify project.",
                    file=sys.stderr,
                )
                sys.exit(1)

        if git_name not in self.metadata or name not in self.metadata[git_name]:
            print(
                f"Error: Worktree '{name}' not found for project '{git_name}'",
                file=sys.stderr,
            )
            sys.exit(1)

        worktree_info = self.metadata[git_name][name]
        original_repo = worktree_info["original_repo"]
        branch_name = worktree_info["branch"]

        # Get the main branch name
        try:
            result = subprocess.run(
                [
                    "git",
                    "-C",
                    original_repo,
                    "symbolic-ref",
                    "refs/remotes/origin/HEAD",
                ],
                capture_output=True,
                text=True,
                check=True,
            )
            main_branch = result.stdout.strip().split("/")[-1]
        except subprocess.CalledProcessError:
            # Fallback to common main branch names
            for branch in ["main", "master"]:
                result = subprocess.run(
                    ["git", "-C", original_repo, "rev-parse", "--verify", branch],
                    capture_output=True,
                    check=True,
                )
                if result.returncode == 0:
                    main_branch = branch
                    break
            else:
                main_branch = "main"

        print(f"Merging branch '{branch_name}' into '{main_branch}' in {original_repo}")

        # Checkout main branch
        try:
            subprocess.run(
                ["git", "-C", original_repo, "checkout", main_branch], check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"Error checking out {main_branch}: {e}", file=sys.stderr)
            sys.exit(1)

        # Merge the worktree branch
        try:
            subprocess.run(
                ["git", "-C", original_repo, "merge", branch_name], check=True
            )
            print(f"Successfully merged '{branch_name}' into '{main_branch}'")
        except subprocess.CalledProcessError as e:
            print(f"Error merging branch: {e}", file=sys.stderr)
            print("You may need to resolve conflicts manually")
            sys.exit(1)

    def agent(self, name: str, task: str, project: Optional[str] = None):
        """Create a new worktree with venv and launch Claude agent with task"""
        # Use common worktree creation logic
        git_name, worktree_path, venv_path, branch_name = self._create_worktree_common(
            name, project
        )

        # Launch Claude agent with task
        print(f"\nLaunching Claude agent with task: {task}")
        try:
            subprocess.run(
                ["claude", "-D", str(worktree_path), task],
                check=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"\nError running Claude: {e}", file=sys.stderr)
            sys.exit(1)
        except FileNotFoundError:
            print(
                "\nError: 'claude' command not found. Make sure Claude CLI is installed.",
                file=sys.stderr,
            )
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Git worktree manager for AI agent workflows",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # create command
    create_parser = subparsers.add_parser(
        "create", help="Create a new worktree with venv"
    )
    create_parser.add_argument("name", help="Name of the worktree")
    create_parser.add_argument(
        "-p", "--project", help="Project name (defaults to current git repo name)"
    )

    # edit command
    edit_parser = subparsers.add_parser("edit", help="Open worktree in VS Code")
    edit_parser.add_argument("name", help="Name of the worktree")
    edit_parser.add_argument(
        "-p", "--project", help="Project name (defaults to current git repo name)"
    )

    # delete command
    delete_parser = subparsers.add_parser("delete", help="Delete a worktree")
    delete_parser.add_argument("name", help="Name of the worktree")
    delete_parser.add_argument(
        "-p", "--project", help="Project name (defaults to current git repo name)"
    )

    # list command
    list_parser = subparsers.add_parser("list", help="List all worktrees")
    list_parser.add_argument(
        "-p", "--project", help="Project name (show only this project)"
    )

    # merge command
    merge_parser = subparsers.add_parser(
        "merge", help="Merge worktree branch into main"
    )
    merge_parser.add_argument("name", help="Name of the worktree")
    merge_parser.add_argument(
        "-p", "--project", help="Project name (defaults to current git repo name)"
    )

    # agent command
    agent_parser = subparsers.add_parser(
        "agent", help="Create a worktree and launch Claude agent with task"
    )
    agent_parser.add_argument("name", help="Name of the worktree")
    agent_parser.add_argument("task", nargs="+", help="Task description for the agent")
    agent_parser.add_argument(
        "-p", "--project", help="Project name (defaults to current git repo name)"
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    manager = ContxtManager()

    if args.command == "create":
        manager.create(args.name, args.project)
    elif args.command == "edit":
        manager.edit(args.name, args.project)
    elif args.command == "delete":
        manager.delete(args.name, args.project)
    elif args.command == "list":
        manager.list(args.project)
    elif args.command == "merge":
        manager.merge(args.name, args.project)
    elif args.command == "agent":
        task = " ".join(args.task)
        manager.agent(args.name, task, args.project)


if __name__ == "__main__":
    main()
